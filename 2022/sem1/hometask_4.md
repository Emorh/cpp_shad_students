Задача - оптимизировать поиск организаций по телефону.

Программа делает следующее:

* Формирует конкретный набор организаций и их филиалов. У каждого филиала указано множество телефонов в человекочитаемом виде.
* Формирует строку для поиска по номеру телефона
* Выполняет поиск по номеру телефона и возвращает строку, содержащую данные об организациях и филиалах с найденным номером

Референсное решение, которое нужно оптимизировать:

https://github.com/ivafanas/cpp_shad_students/blob/master/2021/sem1/lab4_ref/reference.cpp

Чтобы посмотреть на скорость выполнения решения, вставьте его содержимое на сайте quick-bench.com

Ваша задача - скопировать референсное решение, изменить его и добавить в тест `YourSolution`. Ваше решение должно быть быстрее референсного. Обратите внимание, что чем ниже столбик, тем решение быстрее.

Критерии оценки (по 1 баллу за каждые 10% ускорения):

* Пусть X - оценка производительности референсного решения, данная сайтом quick-bench.com.
* Пусть y - оценка производительности Вашего решения, данная сайтом quick-bench.com
* Количество баллов = `10 * (X - y) / X` (округление делаем в сторону увеличения баллов)

Требования:

* запрещено изменять тестируемые данные (имена организаций и номера телефонов)
* запрещено применять `constexpr`-оптимизации
* запрещено использовать глобальные переменные
* запрещено убирать `benchmark::DoNotOptimize` (для локального тестирования закомментируйте, а при проверке на сайте - раскомментируйте)
* запрещено убирать `__attribute__((noinline))`
* размер символов в телефоне не ограничен (как в форматированном, так и в неформатированном варианте)
* программа должна работать сравнительно честно
  * нельзя "угадывать" ответ только потому что Вы видите его глазами и можете посчитать вручную.
  * программа должна работать корректно и для других входных данных, не только заданных в примере
  * программа может оптимизировать своё выполнение для часто встречающихся данных или ожидаемого поведения (например, можно предположить, что обычно у филиала не более 5 телефонов, но нельзя сломаться для случая, когда у филиала оказалось 7 телефонов)
* некорректно работающая программа за решение не засчитывается (для себя предусмотрите возможность проверки, что Ваши оптимизации не сломали алгоритм)
* формат сдачи задания: на сайт CS-центра присылайте код, который можно скопипастить в quick-bench.com и увидеть результат, а также текстовое описание русским языком применённых оптимизаций (ЧТО было сделано).
* В присылаемом файле должны быть два решения - референсное в `namespace ref` и Ваше в другом `namespace` (Т.е. две бенчмарки). Это нужно, чтобы исключить вариации железа на quick-bench.com.

Замечаний по ревью по задаче не будет (если отдельно не пожелаете).

Попытайтесь не откладывать всё на последний день, чтобы дружной командой не за-DDOS-сить quick-bench.com. (DDOS quick-bench.com в последние три дня за отмазку не принимается).

Примеры некорректных оптимизаций, применённых студентами:

* В данных примерах выносится генерация организаций в глобальную переменную (в первом варианте явно, во втором - неявно). Итого в тесте `run` запускается много-много раз, а `gen_data` во время тестирования не вызывается. Также под тестирование не попадает вызов деструктора orgs. Данный пример ломает тест, но не ускоряет работу кода по созданию организаций и поиску.

``` c++
const auto orgs = gen_data();

std::string run()
{
    benchmark::DoNotOptimize(orgs);
    const auto request = get_search_string();
    return search_by_phone(orgs, request);
}
```

``` c++
std::string run()
{
    static const auto orgs = gen_data();
    benchmark::DoNotOptimize(orgs);
    const auto request = get_search_string();
    return search_by_phone(orgs, request);
}
```

* Нельзя вешать `noexcept` на `gen_data` и `search_by_phone`, т.к. в этом случае поведение алгоритмов при нехватке памяти отличается.
* Со смертью объекта типа `Orgs` должны вычищаться из памяти все данные об организациях/телефонах/филиалах.

Проверяемая конфигурация:

`clang 8.0 LLVM libc++, C++17, -O2`

